<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Website</title>
    <link rel="stylesheet" href="../css/default_blog_post.css">
    <link rel="icon" href="./favicon.ico" type="image/x-icon">
</head>
  
<body>

    <a href="../index.html" id="back">back</a>
    <main>
        <h1>Checking NTFS Execution Permissions with the Win32 API in C++.</h1>
        <p>For people who have never worked with Win32 before (AKA, me, a day before starting to write this blog post).</p>
        <address>By <a href="mailto:programsym987@gmail.com">56DEV_</a></address>
        <h2>Contents</h2>
        <ul>
            <li><a href="#introduction">Introduction</a></li>
            <ul>
                <li><a href="#environment">Environment</a></li>
                <li><a href="#disclaimer">Disclaimer</a></li>
            </ul>
            <li><a href="#security-descriptors">Security Descriptors</a></li>
            <ul>
                <li><a href="#CODE-security-descriptors">Code</a></li>
            </ul>
        </ul>
        <h2 id="introduction">Introduction</h2>
        <p>
            Finding execution permissions is not as simple in Windows as it is in 
            POSIX-style systems. Usually you would just use <code>std::filesystem::status::permissions</code>,
            which, in theory, <em>could</em> actually work, but we're just going to learn to "proper" way to 
            do it in Windows. 
        </p>

        <h3 id="environment">Environment</h3>
        <p>This is in Visual Studio 2022, with <b>C++20</b>. As far as I know, C++17 should work, as that 
        is the minimum version for the <code>std::filesystem</code> library.</p>

        <h3 id="disclaimer">Disclaimer</h3>
        <p>If the subtitle wasn't clear enough, I'm no accredited expert on the Win32 API or even of C++. If you find an error or find a section which you would like some 
            better citations for, please email!
        </p>

        <h2 ID="security-descriptors">Security Descriptors</h2>
        <p>
            To store file permissions, Windows uses <b>Security Descriptors</b>. These are made up of 
            an <b>owner SID</b>, <b>group SID</b>, a <b>DACL</b>, and a <b>SACL</b>. 
            <ul>
            <li>The owner SID is usually the person who created the file, 
            or generally a person with <b>administrative permissions</b> over it.</li>            
            <li>The group SID is there for compatibility with the POSIX permissions system. </li>
            <li>The DACL is the <b>access control list</b> 
            that defines more specific Windows permissions.</li> 
            <li>The SACL's only use is auditing.</li>
            </ul>
            We're not interested in auditing, so SACLs won't be in the scope of this post.
        </p>
        <p>
            To access the security descriptor, we use the <code>GetNamedSecurityInfo</code> function.
        </p>

        

        <h3 id="CODE-security-descriptors">The Code</h3>
        <p>
            To do this in C++, you need to use the <code>GetNamedSecurityInfo</code> function.
            (Or a suitable alternative, but we're using this one in this tutorial.) We will beam the information it gives 
            into a security descriptor variable.
            First, make sure you have the necessary header files included: they are <code>&lt;windows.h&gt;</code>
            and <code>&lt;aclapi.h&gt;</code>. Then, let's create the object.
        </p>

        <p>The function definition for  <code>GetNamedSecurityInfo</code> is as follows:</p>
       
        <code>
            <pre>
                DWORD GetNamedSecurityInfo( 
                    LPCSTR pObjectName, 
                    SE_OBJECT_TYPE ObjectType, 
                    SECURITY_INFORMATION SecurityInfo,
                    [out, opt] PSID* ppsidOwner, 
                    [out, opt] PSID* ppsidGroup, 
                    [out, opt] PACL ppDACL, 
                    [out, opt] PACL* ppSACL, 
                    [out, opt] PSECURITY_DESCRIPTOR* ppSecurityDescriptor)  
            </pre>            
        </code>

        <p>Every out paramater is optional. The first four out parameters are if we wanted to access each data structure 
            individually, but we don't. So, we'll just pass in the address of a <code>PESECURITY_DESCRIPTOR</code> object as the last 
            argument, and let everything else be null. 
        </p>
        
        <code>
        <pre>
        PSECURITY_DESCRIPTOR pSD{ nullptr };

        DWORD result = GetNamedSecurityInfo(
            path.c_str(),
            SE_FILE_OBJECT,
            OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
            nullptr,
            nullptr,
            nullptr,
            nullptr,
            &pSD
        );


        if (result != ERROR_SUCCESS)
        {
            std::cout << "unable to get sec info" << std::endl;
            return false;
        }</pre></code>

        <p>Why not <code>GetSecurityInfo</code>?</p>

        <p>Why <code>c_str()</code>?</p>

        <p>How does the argument for <code>SecurityInfo</code> work?</p>

        <p>Please note that you will need to <b>free</b> the <code>PSECURITY_DESCRIPTOR</code> object later 
        using <code>LocalFree</code>. The reason is this object is dynamically-allocated memory, and not freeing it 
        will result in memory leaks.</p>

        
        
        <p>PS: my original writeup for this section was real lengthy, but that was the point I figured that nothing 
            explains code better than the code itself.
        </p>


        <h2 id="process-threads-and-impersonation">Processes, Threads, and Impersonation</h2>

        <p>
            You probably know that in Windows, processes have <b>threads</b> which are the actual paths of execution
            of a program. Processes and threads have <b>access tokens</b>, which are (oversimplified a bit) used 
            so the operating system can judge their privileges, rights, and permissions.
        </p>

        <p>
            Windows uses the <b>impersonation model</b>, for reasons related to preventing <b>race conditions</b>.
            In this model, there are two kinds of access tokens: primary tokens and impersonation tokens.
        </p>

        <p>
            Let's not overcomplicate: primary tokens are process tokens, and impersonation tokens are thread tokens.
            Don't get too hung up on what "impersonation" even really implies: I don't even know myself.
        </p>

        <p>
            Threads don't usually have their own tokens. They merely inherit the primary token, and use it to perform 
            their operations. However, certain actions need threads to have their own token, such as when 
            you want threads to execute in their own security context. Calling 
            <code>AccessCheck</code> also requires you to have a thread token, even though, in this case, 
            we won't be altering the security context at all. Hence, we will need to create one. We don't need to change anything: 
            we just want the thread token to refer to the same security context as the process token. 
        </p>

        <h3 id="CODE-processes-threads-and-impersonation">The Code</h3>
        
        <pre>
            <code>
            if (!ImpersonateSelf(SecurityImpersonation))
            {
                std::cout << "unable to impersonate" << std::endl;
                return false;
            }
            </code>
        </pre>

        <p>In reality, <code>ImpersonateSelf</code> is shorthand for calls to several functions. It:
        <ul>
            <li>Opens the primary token.</li>
            <li>Duplicates it as a thread token.</li>
            <li>Assigns the thread token to the thread.</li>
        </ul></p>

        <p>In this way, you now have an actual thread-version copy of the process token!</p>
        <p>
            NOTE: later, when you're done impersonating, you will need to call <code>RevertToSelf</code>
            in order to discard the thread token.
        </p>
        
        <h2></h2>
        
        

        

        <h2 id="sources">Sources</h2>
        <p>Also treat this as further reading!</p>
        <h3>Books</h3>
        <ul>
            <li><i>Programming Windows Security</i> by Keith Brown</li>
        </ul>
        <h3>Websites</h3>
        <ul>
            <li>https://learn.microsoft.com/en-us/windows/win32/secauthz/access-control-lists</li>
        </ul>
    </main>


</body>
</html>